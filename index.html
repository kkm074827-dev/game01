import React, { useState, useEffect, useCallback } from 'react';
import { Flag, Bomb, RefreshCw, Trophy, Skull, Clock, Target } from 'lucide-react';

const DIFFICULTIES = {
  beginner: { rows: 9, cols: 9, mines: 10, label: 'åˆç´š' },
  intermediate: { rows: 16, cols: 16, mines: 40, label: 'ä¸­ç´š' },
  expert: { rows: 16, cols: 30, mines: 99, label: 'é«˜ç´š' },
};

const CELL_COLORS = [
  '',
  'text-blue-500',   // 1
  'text-green-500',  // 2
  'text-red-500',    // 3
  'text-purple-600', // 4
  'text-red-800',    // 5
  'text-teal-600',   // 6
  'text-black',      // 7
  'text-gray-500',   // 8
];

export default function App() {
  const [difficulty, setDifficulty] = useState('beginner');
  const [grid, setGrid] = useState([]);
  const [gameState, setGameState] = useState('idle'); // idle, playing, won, lost
  const [mineCount, setMineCount] = useState(0);
  const [timer, setTimer] = useState(0);
  const [isFlagMode, setIsFlagMode] = useState(false); // For mobile users

  // Initialize Game
  const initGame = useCallback(() => {
    const config = DIFFICULTIES[difficulty];
    const newGrid = [];
    
    // Create empty grid
    for (let r = 0; r < config.rows; r++) {
      const row = [];
      for (let c = 0; c < config.cols; c++) {
        row.push({
          row: r,
          col: c,
          isMine: false,
          isRevealed: false,
          isFlagged: false,
          neighborMines: 0,
        });
      }
      newGrid.push(row);
    }

    // Place Mines
    let minesPlaced = 0;
    while (minesPlaced < config.mines) {
      const r = Math.floor(Math.random() * config.rows);
      const c = Math.floor(Math.random() * config.cols);
      if (!newGrid[r][c].isMine) {
        newGrid[r][c].isMine = true;
        minesPlaced++;
      }
    }

    // Calculate neighbors
    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];

    for (let r = 0; r < config.rows; r++) {
      for (let c = 0; c < config.cols; c++) {
        if (!newGrid[r][c].isMine) {
          let count = 0;
          directions.forEach(([dr, dc]) => {
            const nr = r + dr;
            const nc = c + dc;
            if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols && newGrid[nr][nc].isMine) {
              count++;
            }
          });
          newGrid[r][c].neighborMines = count;
        }
      }
    }

    setGrid(newGrid);
    setGameState('idle');
    setMineCount(config.mines);
    setTimer(0);
    setIsFlagMode(false);
  }, [difficulty]);

  useEffect(() => {
    initGame();
  }, [initGame]);

  // Timer
  useEffect(() => {
    let interval;
    if (gameState === 'playing') {
      interval = setInterval(() => {
        setTimer((t) => t + 1);
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [gameState]);

  // Reveal Cell Logic (Recursive flood fill)
  const revealCell = (board, r, c) => {
    if (r < 0 || r >= board.length || c < 0 || c >= board[0].length || board[r][c].isRevealed || board[r][c].isFlagged) {
      return;
    }

    board[r][c].isRevealed = true;

    if (board[r][c].neighborMines === 0 && !board[r][c].isMine) {
      const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1],           [0, 1],
        [1, -1],  [1, 0],  [1, 1]
      ];
      directions.forEach(([dr, dc]) => {
        revealCell(board, r + dr, c + dc);
      });
    }
  };

  const checkWin = (board) => {
    const config = DIFFICULTIES[difficulty];
    let revealedCount = 0;
    for (let r = 0; r < config.rows; r++) {
      for (let c = 0; c < config.cols; c++) {
        if (board[r][c].isRevealed) revealedCount++;
      }
    }
    return revealedCount === (config.rows * config.cols - config.mines);
  };

  const handleCellClick = (r, c) => {
    if (gameState === 'lost' || gameState === 'won') return;
    
    // Handle Flag Mode (for mobile mostly)
    if (isFlagMode) {
      handleRightClick(null, r, c);
      return;
    }

    const newGrid = [...grid.map(row => [...row])]; // Deep copy
    const cell = newGrid[r][c];

    if (cell.isFlagged || cell.isRevealed) return;

    if (gameState === 'idle') setGameState('playing');

    if (cell.isMine) {
      // Game Over
      cell.isRevealed = true;
      // Reveal all mines
      newGrid.forEach(row => row.forEach(c => {
        if (c.isMine) c.isRevealed = true;
      }));
      setGrid(newGrid);
      setGameState('lost');
    } else {
      revealCell(newGrid, r, c);
      setGrid(newGrid);
      if (checkWin(newGrid)) {
        setGameState('won');
      }
    }
  };

  const handleRightClick = (e, r, c) => {
    if (e) e.preventDefault();
    if (gameState === 'lost' || gameState === 'won') return;

    const newGrid = [...grid.map(row => [...row])];
    const cell = newGrid[r][c];

    if (cell.isRevealed) return;

    if (cell.isFlagged) {
      cell.isFlagged = false;
      setMineCount(m => m + 1);
    } else {
      cell.isFlagged = true;
      setMineCount(m => m - 1);
    }
    setGrid(newGrid);
  };

  const getCellContent = (cell) => {
    if (cell.isFlagged) return <Flag size={16} className="text-red-500 fill-red-500" />;
    if (!cell.isRevealed) return null;
    if (cell.isMine) return <Bomb size={18} className="text-black fill-black" />;
    if (cell.neighborMines > 0) return <span className={`font-bold ${CELL_COLORS[cell.neighborMines]}`}>{cell.neighborMines}</span>;
    return null;
  };

  return (
    <div className="min-h-screen bg-slate-100 flex flex-col items-center justify-center p-4 font-sans select-none">
      
      {/* Game Container */}
      <div className="bg-white p-4 sm:p-6 rounded-xl shadow-xl border-4 border-slate-300 w-full max-w-4xl flex flex-col items-center">
        
        {/* Header: Difficulty & Status */}
        <div className="w-full flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
          <div className="flex gap-2">
            {Object.keys(DIFFICULTIES).map((key) => (
              <button
                key={key}
                onClick={() => setDifficulty(key)}
                className={`px-3 py-1.5 rounded-lg text-sm font-semibold transition-all ${
                  difficulty === key 
                  ? 'bg-blue-600 text-white shadow-md scale-105' 
                  : 'bg-slate-200 text-slate-600 hover:bg-slate-300'
                }`}
              >
                {DIFFICULTIES[key].label}
              </button>
            ))}
          </div>
          
          <div className="flex items-center gap-6 bg-slate-100 px-4 py-2 rounded-lg border border-slate-200 shadow-inner">
             <div className="flex items-center gap-2 text-red-600 font-mono font-bold text-xl min-w-[60px]">
                <Flag size={20} />
                <span>{mineCount}</span>
             </div>
             
             <button 
                onClick={initGame}
                className="p-2 bg-yellow-400 hover:bg-yellow-300 active:scale-95 rounded-full border-2 border-yellow-600 shadow-sm transition-transform"
             >
                {gameState === 'lost' ? <Skull size={24} className="text-slate-800" /> : 
                 gameState === 'won' ? <Trophy size={24} className="text-slate-800" /> : 
                 <RefreshCw size={24} className="text-slate-800" />}
             </button>

             <div className="flex items-center gap-2 text-slate-700 font-mono font-bold text-xl min-w-[60px] justify-end">
                <span>{String(timer).padStart(3, '0')}</span>
                <Clock size={20} />
             </div>
          </div>
        </div>

        {/* Mobile Flag Toggle */}
        <div className="md:hidden w-full flex justify-center mb-4">
          <button
            onClick={() => setIsFlagMode(!isFlagMode)}
            className={`flex items-center gap-2 px-6 py-2 rounded-full font-bold shadow-md transition-all ${
              isFlagMode 
              ? 'bg-red-500 text-white ring-2 ring-red-300' 
              : 'bg-slate-200 text-slate-600'
            }`}
          >
            {isFlagMode ? <Flag size={18} className="fill-current" /> : <Target size={18} />}
            {isFlagMode ? "æ’æ——æ¨¡å¼ ON" : "æŒ–æ˜æ¨¡å¼"}
          </button>
        </div>

        {/* Game Grid Container - Handles scrolling for large boards */}
        <div className="w-full overflow-auto flex justify-center bg-slate-200 p-2 sm:p-4 rounded-lg border-inner shadow-inner">
          <div 
            className="grid gap-[2px] bg-slate-400 border-2 border-slate-400"
            style={{
              gridTemplateColumns: `repeat(${DIFFICULTIES[difficulty].cols}, minmax(0, 1fr))`,
              width: 'max-content' 
            }}
          >
            {grid.map((row, r) => 
              row.map((cell, c) => (
                <div
                  key={`${r}-${c}`}
                  onClick={() => handleCellClick(r, c)}
                  onContextMenu={(e) => handleRightClick(e, r, c)}
                  className={`
                    w-8 h-8 sm:w-9 sm:h-9 flex items-center justify-center text-sm sm:text-lg font-bold cursor-pointer transition-colors duration-75
                    ${cell.isRevealed 
                      ? 'bg-slate-100 border border-slate-200 shadow-none' 
                      : 'bg-slate-300 hover:bg-slate-200 border-t-4 border-l-4 border-slate-100 border-b-4 border-r-4 border-slate-400 active:border-none shadow-sm'
                    }
                    ${cell.isRevealed && cell.isMine ? 'bg-red-400' : ''}
                  `}
                >
                  {getCellContent(cell)}
                </div>
              ))
            )}
          </div>
        </div>

        {/* Game End Message */}
        {gameState !== 'idle' && gameState !== 'playing' && (
           <div className={`mt-6 p-4 rounded-lg text-center w-full animate-bounce ${
             gameState === 'won' ? 'bg-green-100 text-green-800 border border-green-300' : 'bg-red-100 text-red-800 border border-red-300'
           }`}>
             <h2 className="text-2xl font-bold">
               {gameState === 'won' ? 'ğŸ‰ æ­å–œå‹åˆ©ï¼' : 'ğŸ’¥ è¸©åˆ°åœ°é›·äº†ï¼'}
             </h2>
             <p className="mt-1">
               {gameState === 'won' ? `ç”¨æ™‚: ${timer} ç§’` : 'å†è©¦ä¸€æ¬¡å§ï¼Ÿ'}
             </p>
           </div>
        )}
      </div>
      
      <div className="mt-4 text-slate-400 text-xs">
        <p>é›»è…¦ç‰ˆï¼šå·¦éµæŒ–æ˜ / å³éµæ’æ——</p>
        <p>æ‰‹æ©Ÿç‰ˆï¼šä½¿ç”¨ä¸Šæ–¹æŒ‰éˆ•åˆ‡æ›æ¨¡å¼</p>
      </div>
    </div>
  );
}
